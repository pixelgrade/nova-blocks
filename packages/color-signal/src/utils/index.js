import { getSignals } from "@novablocks/utils";

export { getColorSignalClassnames } from "@novablocks/utils";

// Helper function to get current Palette Config,
// and generate a default, if a palette does not exist.
export const getCurrentPaletteConfig = ( props ) => {
  const { attributes, settings } = props;
  const { palette } = attributes;
  const { palettes } = settings;

  if ( ! Array.isArray( palettes ) || ! palettes.length ) {
    return { sourceIndex: 6 }
  }

  return palettes.find( paletteIterator => paletteIterator.id === palette ) || palettes[0];
};

export const mapPalettesToColorPalette = palette => {
  const { colors, sourceIndex } = palette;
  return {
    name: palette.label,
    color: colors[sourceIndex].value
  };
};

export const getSiteColorVariation = ( () => {

  const api = window.parent?.wp?.customize || window.wp?.customize;
  let initialSiteVariation = window?.styleManager?.siteColorVariation || 1;

  if ( api ) {
    api( 'sm_site_color_variation', setting => {
      setting.bind( newValue => {
        initialSiteVariation = parseInt( newValue, 10 );
      } );
    } );
  }

  return () => {
    return initialSiteVariation;
  };

} )();

export const getPaletteConfig = ( palette ) => {
  const palettes = window.styleManager?.colorsConfig || [];

  if ( ! Array.isArray( palettes ) || ! palettes.length ) {
    return { sourceIndex: 6 }
  }

  return palettes.find( paletteIterator => `${ paletteIterator.id }` === `${ palette }` ) || palettes[0];
};

/**
 * For a given set of attributes, return the absolute variation value
 * which can differ from the actual paletteVariation attribute value
 * when the useSourceColorAsReference attribute is set to true or Palette Basis Offset is different than 1
 * @param attributes
 * @returns {*}
 */
export const getAbsoluteColorVariation = ( attributes ) => {
  const { palette, useSourceColorAsReference } = attributes;
  const paletteVariation = parseInt( attributes.paletteVariation, 10 );
  const sourceIndex = getSourceIndexFromPaletteId( palette );
  const absoluteVariation = useSourceColorAsReference ? sourceIndex + 1 : paletteVariation;

  return addSiteVariationOffset( absoluteVariation );
};



export const getVariationFromSignal = ( signal, paletteId ) => {
  const signals = getSignals( paletteId );
  const variation = signals[ Math.min( signal, signals.length - 1 ) ];

  return removeSiteVariationOffset( variation );
};

/**
 * Calculate what's the colorSignal generated by a variation for a given reference variation
 * @param compared the paletteVariation to be used
 * @param reference the block's parent variation or any given reference variation for that matter
 * @returns {*}
 */
export const getSignalRelativeToVariation = ( compared, reference, paletteId ) => {
  const variationOptions = getSignalOptionsFromVariation( reference, paletteId );

  const signal = variationOptions.reduce( ( prev, curr, index, arr ) => {
    return ( Math.abs(curr - compared ) < Math.abs( arr[prev] - compared ) ? index : prev );
  }, 0 );

  const palette = getPaletteConfig( paletteId );

  if ( ! palette.colors ) {
    return signal;
  }

  let colors = palette.colors;

  if ( Array.isArray( palette?.variations ) ) {
      colors = palette.variations.map( variation => variation.bg );
  }

  // try to use signal 0 only when compared and reference are equal
  return colors[ compared - 1 ] === colors[ reference - 1 ] ? 0 : Math.max(1, signal );
};

/**
 * For a given reference value, returns an array containing the paletteVariation values generated
 * by every colorSignal value from 0 to 3
 * @param variation
 * @returns {*[]}
 */
export const getSignalOptionsFromVariation = ( variation, paletteId ) => {
  const variationOptions = getSignals( paletteId );

  variationOptions.sort( ( variation1, variation2 ) => {
    return Math.abs( variation - variation1 ) < Math.abs( variation - variation2 ) ? -1 : 1;
  } );

  variationOptions[0] = variation;

  return variationOptions;
};

/**
 * For a given pair of a reference paletteVariation and a colorSignal value return a new paletteVariation value
 * If the signal between the reference and the current variation is the same as the passed colorSignal value
 * We return the current paletteVariation instead of calculating it again, since it's probably a value
 * intentionally chosen by the user.
 * @param reference the reference variation to compute the colorSignal on
 * @param colorSignal the desired colorSignal value
 * @param paletteVariation the block's current paletteVariation attribute's value
 * @returns {*}
 */
export const computeColorSignal = ( reference, colorSignal, paletteId, paletteVariation = false ) => {
  const signalOptions = getSignalOptionsFromVariation( reference, paletteId );

  if ( Number.isInteger( paletteVariation ) ) {
    const currentSignal = getSignalRelativeToVariation( paletteVariation, reference, paletteId );

    if ( currentSignal === colorSignal ) {
      return paletteVariation;
    }
  }

  const finalColorSignal = Math.min( signalOptions.length - 1, colorSignal );

  return signalOptions[ finalColorSignal ];
};

/**
 * Returns a palette's source color position after it has been shifted with the Palette Basis Offset option
 * @param palette
 * @returns {number}
 */
export const getSourceIndexFromPaletteId = ( palette ) => {
  const paletteConfig = getPaletteConfig( palette );
  const siteVariation = getSiteColorVariation();
  const { sourceIndex } = paletteConfig;

  return ( sourceIndex - siteVariation + 1 + 12 ) % 12;
};

/**
 * Add the value of the Palette Basis Offset control to a variation to simplify calculations
 * @param variation
 * @returns {*}
 */
export const addSiteVariationOffset = ( variation ) => {
  const siteVariation = getSiteColorVariation();
  return normalizeVariationValue( variation + siteVariation - 1 );
};

/**
 * Remove the value of the Palette Basis Offset control, that was previously added to simplify calculations
 * @param variation
 * @returns {*}
 */
export const removeSiteVariationOffset = ( variation ) => {
  const siteVariation = getSiteColorVariation();
  return normalizeVariationValue( variation - siteVariation + 1 );
};

export const normalizeVariationValue = ( value ) => {
  return ( value + 11 ) % 12 + 1;
};

export const getMaxSignal = ( paletteId ) => {
  const signals = getSignals( paletteId );

  return signals.length - 1;
};
